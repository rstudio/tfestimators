tf_estimator <- function(estimator, classes, history = NULL, args = NULL) {
  structure(
    list(
      estimator = estimator,
      history = history,
      args = args),
    class = c("tf_estimator", paste("tf_estimator", classes, sep = "_"))
  )
}

tf_regressor <- function(estimator, class, args = NULL) {
  tf_estimator(estimator, c("regressor", class), args = args)
}

tf_classifier <- function(estimator, class, args = NULL) {
  tf_estimator(estimator, c("classifier", class), args = args)
}

#' @param input_fn An input function, typically generated by the [input_fn()]
#'   helper function.
#'
#' @param hooks A list of \R functions, to be used as callbacks inside the
#'   training loop.
#'
#' @param checkpoint_path The path to a specific model checkpoint to be used for
#'   prediction. If `NULL` (the default), the latest checkpoint in `model_dir`
#'   is used.
#'   
#' @param steps The number of steps for which the model should be trained on
#'   this particular `train()` invocation. If `NULL` (the default), this function
#'   will either train forever, or until the supplied `input_fn()` has provided
#'   all available data.
#'   
#' @param max_steps The total number of steps for which the model should be
#'   trained. If set, `steps` must be `NULL`. If the estimator has already been
#'   trained a total of `max_steps` times, then no training will be performed.
#'
#' @param as_iterable Boolean; should a raw Python generator be returned? When
#'   `FALSE` (the default), the predicted values will be consumed from the
#'   generator and returned as an \R object.
#'
#' @name train-evaluate-predict
NULL

#' Train an Estimator
#'
#' Train an estimator on a set of input data provides by the `input_fn()`.
#'
#' @inheritParams train-evaluate-predict
#'
#' @template roxlate-object-estimator
#'
#' @param verbose Show progress output as the model is trained?
#' @param view_metrics View training metrics as the model is trained?
#' @param ... Optional arguments, passed on to the estimator's `train()` method.
#'
#' @export
#' @family custom estimator methods
train.tf_estimator <- function(object,
                               input_fn,
                               steps = NULL,
                               hooks = NULL,
                               max_steps = NULL,
                               verbose = TRUE,
                               view_metrics = "auto",
                               ...)
{
  if (verbose) {
    .globals$history <- tf_estimator_history()
    hooks <- c(hooks, hook_history_saver())
    hooks <- c(hooks, hook_progress_bar("Training", steps))
  }
  
  if (resolve_view_metrics(view_metrics, verbose))
    hooks <- c(hooks, hook_view_metrics(steps))
  
  # show training loss metrics
  # (https://www.tensorflow.org/get_started/monitors#enabling_logging_with_tensorflow)
  with_logging_verbosity(tf$logging$WARN, {
    object$estimator$train(
      input_fn = normalize_input_fn(object, input_fn),
      steps = as_nullable_integer(steps),
      hooks = normalize_session_run_hooks(hooks),
      max_steps = as_nullable_integer(max_steps),
      ...
    )
  })
  
  if (verbose)
    object$history <- .globals$history
  
  invisible(object)
}

#' Generate Predictions with an Estimator
#'
#' Generate predicted labels / values for input data provided by `input_fn()`.
#'
#' @inheritParams train-evaluate-predict
#'
#' @template roxlate-object-estimator
#'
#' @param predict_keys The types of predictions that should be produced, as an
#'   \R list. When `NULL` (the default), all possible predicted values will be
#'   returned. The [prediction_keys()] function provides the set of possible
#'   prediction keys that can be supplied here.
#' @param ... Optional arguments passed on to the estimator's `predict()`
#'   method.
#'
#' @section Yields: Evaluated values of `predictions` tensors.
#'
#' @section Raises: ValueError: Could not find a trained model in model_dir.
#'   ValueError: if batch length of predictions are not same. ValueError: If
#'   there is a conflict between `predict_keys` and `predictions`. For example
#'   if `predict_keys` is not `NULL` but `EstimatorSpec.predictions` is not a
#'   `dict`.
#'
#' @export
#' @family custom estimator methods
predict.tf_estimator <- function(object,
                                 input_fn,
                                 checkpoint_path = NULL,
                                 predict_keys = NULL,
                                 hooks = NULL,
                                 as_iterable = FALSE,
                                 ...)
{
  predictions <- object$estimator$predict(
    input_fn = normalize_input_fn(object, input_fn),
    checkpoint_path = checkpoint_path,
    hooks = normalize_session_run_hooks(hooks),
    predict_keys = predict_keys,
    ...
  )

  if (!as_iterable) {
    if (!any(inherits(predictions, "python.builtin.iterator"),
             inherits(predictions, "python.builtin.generator"))) {
      warning("predictions are not iterable, no need to convert again")
    } else {
      predictions <- predictions %>% iterate
    }
  }
  predictions
}

#' Evaluate an Estimator
#'
#' Evaluate an estimator on input data provided by an `input_fn()`.
#'
#' For each step, this method will call `input_fn()` to produce a single batch
#' of data. Evaluation continues until:
#'
#' - `steps` batches are processed, or
#' - The `input_fn()` is exhausted of data.
#'
#' @inheritParams train-evaluate-predict
#'
#' @template roxlate-object-estimator
#'
#' @param name Name of the evaluation if user needs to run multiple evaluations
#'   on different data sets, such as on training data vs test data. Metrics for
#'   different evaluations are saved in separate folders, and appear separately
#'   in tensorboard.
#' @param verbose Show progress output as the model is trained?
#' @param ... Optional arguments passed on to the estimator's `evaluate()`
#'   method.
#'
#' @return An \R list of evaluation metrics.
#'
#' @export
#' @family custom estimator methods
evaluate.tf_estimator <- function(object,
                                  input_fn,
                                  steps = NULL,
                                  checkpoint_path = NULL,
                                  name = NULL,
                                  hooks = NULL,
                                  verbose = TRUE,
                                  ...)
{
  if (verbose) {
    .globals$history <- tf_estimator_history()
    hooks <- c(hooks, hook_history_saver())
    hooks <- c(hooks, hook_progress_bar("Evaluating", steps))
  }
  
  result <- with_logging_verbosity(tf$logging$WARN, {
    object$estimator$evaluate(
      input_fn = normalize_input_fn(object, input_fn),
      steps = as_nullable_integer(steps),
      checkpoint_path = checkpoint_path,
      name = name,
      hooks = normalize_session_run_hooks(hooks),
      ...
    )
  })
  
  tfruns::write_run_metadata("evaluation", result)
  result
}

#' Save an Estimator
#'
#' Save an estimator (alongside its weights) to the directory `export_dir_base`.
#'
#' TODO: we should document how a user can load a saved model here as well.
#'
#' @details
#'
#' This method builds a new graph by first calling the serving_input_receiver_fn
#' to obtain feature `Tensor`s, and then calling this `Estimator`'s model_fn to
#' generate the model graph based on those features. It restores the given
#' checkpoint (or, lacking that, the most recent checkpoint) into this graph in
#' a fresh session. Finally it creates a timestamped export directory below the
#' given export_dir_base, and writes a `SavedModel` into it containing a single
#' `MetaGraphDef` saved from this session. The exported `MetaGraphDef` will
#' provide one `SignatureDef` for each element of the export_outputs dict
#' returned from the model_fn, named using the same keys. One of these keys is
#' always signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY, indicating
#' which signature will be served when a serving request does not specify one.
#' For each signature, the outputs are provided by the corresponding
#' `ExportOutput`s, and the inputs are always the input receivers provided by
#' the serving_input_receiver_fn. Extra assets may be written into the
#' SavedModel via the extra_assets argument. This should be a dict, where each
#' key gives a destination path (including the filename) relative to the
#' assets.extra directory. The corresponding value gives the full path of the
#' source file to be copied. For example, the simple case of copying a single
#' file without renaming it is specified as `{'my_asset_file.txt':
#' '/path/to/my_asset_file.txt'}`.
#'
#' @template roxlate-object-estimator
#'
#' @param export_dir_base A string containing a directory in which to create
#'   timestamped subdirectories containing exported SavedModels.
#' @param serving_input_receiver_fn A function that takes no argument and
#'   returns a `ServingInputReceiver`. Required for custom models.
#' @param assets_extra A dict specifying how to populate the assets.extra
#'   directory within the exported SavedModel, or `NULL` if no extra assets are
#'   needed.
#' @param as_text whether to write the SavedModel proto in text format.
#' @param checkpoint_path The checkpoint path to export. If `NULL` (the
#'   default), the most recent checkpoint found within the model directory is
#'   chosen.
#' @param ... Optional arguments passed on to the estimator's
#'   `export_savedmodel()` method.
#'
#' @return The path to the exported directory, as a string.
#'
#' @section Raises: ValueError: if no serving_input_receiver_fn is provided, no
#'   export_outputs are provided, or no checkpoint can be found.
#'
#' @export
#' @family custom estimator methods
export_savedmodel.tf_estimator <- function(object,
                                           export_dir_base,
                                           serving_input_receiver_fn = NULL,
                                           assets_extra = NULL,
                                           as_text = FALSE,
                                           checkpoint_path = NULL,
                                           ...)
{
  if (is.null(serving_input_receiver_fn)) {
    if ("tf_custom_estimator" %in% class(object))
      stop("A 'tf_custom_estimator' requires a custom `serving_input_receiver_fn`.")
    
    input_spec <- regressor_parse_example_spec(
      feature_columns = object$args$feature_columns,
      weight_column = object$args$weight_column,
      label_key = "label"
    )
    
    serving_input_receiver_fn <- tf$estimator$export$build_parsing_serving_input_receiver_fn(input_spec)
  }
  
  status <- object$estimator$export_savedmodel(
    export_dir_base = export_dir_base,
    serving_input_receiver_fn = serving_input_receiver_fn,
    assets_extra = assets_extra,
    as_text = as_text,
    checkpoint_path = checkpoint_path,
    ...
  )

  invisible(status)
}

#' Extract Model Coefficients
#'
#' @param object An estimator.
#' @param ... Optional arguments; currently unused.
#'
#' @return A named list of variables, such as each hidden layer's biases and
#' weights matrices (if using any of the DNN estimators), global step, etc.
#'
#' @export
#' @family custom estimator methods
coef.tf_estimator <- function(object, ...) {
  training_lib <- tf$python$training
  model_dir <- object$estimator$model_dir
  ckp <- training_lib$checkpoint_utils$load_checkpoint(get_latest_checkpoint(model_dir))
  var_names <- list_variable_names(model_dir)
  cleaned_vars <- lapply(var_names, function(var_name) ckp$get_tensor(var_name[[1]]))
  names(cleaned_vars) <- var_names
  cleaned_vars
}
